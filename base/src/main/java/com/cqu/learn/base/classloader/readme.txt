Class 文件需要加载到虚拟机之后，才能生效，加载的方式就是通过 ClassLoader
以及它的子类。
类加载的过程：加载 -> 验证 -> 准备 -> 解析 -> 初始化
加载：虚拟机通过类的全限定路径加载这个类字节码文件，从而创建一个 CLass 对象
验证：验证字节码文件对虚拟机是否有害
准备：将类变量初始化，并不赋值
解析：
初始化：成员变量和类变量赋值

类加载器的任务便是通过限定名称找到一个二进制字节码文件，然后将文件内容生成 Class 对象
加载器分为三种：启动类加载器（Bootstrap） -> 扩展类加载器（Extension） -> 系统（应用（System Application））加载器
启动类加载器
主要加载 JAVA 自身的类，加载的路径是 <JAVA_HOME>/lib
和 -Xbootclasspath="dirpath"
并且，只会加载自己认识的类的文件，这主要是为了保证自己的安全

扩展类加载器
由 JAVA 实现，加载 <JAVA_HOME>/lib/ext 目录下和 -Djava.ext.dir="dirpath"

系统类加载器
由 Sun 公司实现，负责加载系统类路径 java-classpath 或者 -D java.class.path
指定路径下的类库，一般使用的就是这个类加载器，使用
ClassLoader#getSystemLoader() 可以获取到该类加载器

加载机制
JAVA 中的类，是按需加载的，使用才会加载，加载的顺序是委派机制，就是说
如果需要加载一个类，会先让父加载器加载，如果父加载器还有父类记载器，就一直
向上委托，直到父类加载器无法加载为止，才会让子类加载器夹加载。
这样做的目的是：重复的类不会重复加载，因为父类已经知道该类已被加载
其次，核心的类只能核心的类加载器加载，所以也保证了安全

ClassLoader 是一个抽象父类，实现了一些类加载的方法：
loadClass(String); 该方法加载指定名称的二进制类型文件，不建议重写但是用户直接调用
因为里面有委派父类的逻辑，在加载的过程中，有是否加载之后就解析的可选项，解析就是
将属性中的。。。，
findClass(String); 这才是开发自定义的类加载方法，这个方法一般就只是指定
加载的 Class 文件的来源，目的是为了和 defineClass() 方法配合
defineClass(byte[] b, int off, int len); 直接将一个二进制流数组，转化为一个 Class 对象
这个方法加载的类对象没有解析过程

这里还涉及到两个类的比较问题，两个类实例完全相同的前提是：
1，他们使用同一个类加载器加载的，只是我们一般都是一个类加载器，所以相同
2，这两个类的包名类名相同，当然类字段肯定要相同

什么时候需要自定义类加载器？
1，一般的类加载器加载不到我们写的特有的类，需要新创建类加载器，并加载某些类
2，网络传输字节码文件，需要加密解密，需要重写 findClass 方法
3，热部署功能

自定义类加载器时，需要继承 ClassLoader 类，并且重写 findClass 方法，该方法用于寻找字节码文件
注意的是，加载类不仅需要传入类的字节码文件，还需要传入类的包名和类名字，也就是类的相对路径
如果加载的类不认识，就只能使用 Object 来存储，并使用反射来调用方法