JAVA 的 I/O 是封装的操作系统的 I/O

对于操作系统而言，I/O 是内存和其他数据存储介质进行数据传输的一种方式
这里的 Input 和 Output 是对于内存而言的。也就是说，但凡是从内存出去的，都是 Output
是写入内存的，就是 Input，而且，数据的传输是单向的，所以要想同时交互数据需要定义 I 和 O
数据的流向主要有这几部分：磁盘（文件）、网络（Socket）、线程间通信等

数据的流向是对于系统内存而言的，那么
流向内存里面，我们称为read，就是读到内存里面去，这个read()方法InputStream和Reader的所有子类都有
都是传入一个字节或者字符数组，并且尽量读取这个数组能够容纳的最大的数据个数或者我们限定的数据个数
然后返回读了多少个单位数据

现在说的是传统的 JAVA I/O，是阻塞的I/O，在操作系统进行数据的传输的时候，该线程会阻塞
什么都不干，这就是阻塞型 I/O

I/O 从传输信息的最小单位上来分可以分为字节和字符
在传输字节方面，有InputStream和OutputStream
在传输字符方面，有Reader和Writer
但其实，计算机底层只能识别二进制码，所以传输的字符最终还是会转化成为字节

从角色方面
有节点流和包装流的区别，节点流就是直接对接到数据的来源或者去向的节点
包装流就是对节点流的一个封装。目的是
1，如果程序员定义的用来存储读取数据的字节字符数组是很小的，或者是不合适的
    那么程序员需要自己多次去手动从磁盘中读取数据到内存中，这样的花销实在太大
    而，包装流内部本身有一个数组对象，是

接下来以文件输入输出对象为例

字符流常用对象

Reader->BufferedReader
           ->InputStreamReader -> FileReader（该对象由File作为构造参数，是一个简单的用字符读取文件内容的对象）
           ->StringReader
           ->PipedReader
           ->ByteArrayReader
           ->FilterReader ->PushbackReader