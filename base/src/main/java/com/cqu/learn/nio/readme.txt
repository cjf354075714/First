一、基本概念

1，NIO 与 IO 的区别
NIO 面向缓冲区，也就是NIO 传输的数据是存在缓存中
IO 面向流，这个流就是用于传输数据的管道，这个管道就是流（其实就是一个叫法而已，本质上是底层的 Native 方法）

IO 是单向的，要么输出，要么输入
NIO 是双向的

2，基本组件
在传递数据的时候，需要先建立一个通道（Channel），建立好通道之后，还需要一个可以传输数据的组件，就是 Buffer
这个 Buffer 在数据传输的两头反复走，就实现了数据的双向流动
对于通道需要有监控对象，就是Selector

3，组件的细节
3.1 Buffer
Buffer 底层就是一个数组，用于存储不用数据类型的数据的，意味着，根据数据类型不同，有不同的数据缓冲 Buffer
可见 Buffer 就是一个抽象父类，比如有 ByteBuffer、CharBuffer、ShortBuffer...
Buffer 实例的方法都差不多，都是通过一个静态方法 allocate() 方法获得缓冲区
缓冲区存取数据的核心方法：put() 和 get() 以及 flip()
缓冲区核心属性：mark、position、limit、capacity
这几个属性和 BufferedInputStream 里面的数组差不多
mark：在数组中的某个索引位进行一个标记
position：表示当前数组读取到数据的位置
limit：限定缓冲区中可以读取数据的大小，后面的数据是不能读取的，一般用来标记后面没有数据
capacity：缓冲区的大小，不可变

flip() 函数通过给 position 和 limit 赋值，使得我们可以从 buffer 里面读取数据，本质上就是限定我们读取数据的多少
rewind() 重置 position 的位置，就可以重复读取数据了
clear() 重置所有的标志位，表示可以重头开始写入数据，但是缓冲区数据还存在，只不过这些数据是不能读取的，因为指针已经被重置了
reset() 方法一般都和 mark 一起使用，这样做的目的是可以回到 mark 的位置，只是会到这个位置，读取都在该位置进行相应的操作
hasRemaining() 判断缓冲区是否还有数据，这里应该是没读到的数据，就是当前 position 和 limit 的差值

直接缓冲区与非直接缓冲区
构造方法的不同，使得这个 buffer 的内存对象在地方的不同，导致读写数据的速度不同
allocate() 返回的 buffer 对象的内存是在 JVM 中的，那么读写的速度肯定是比较慢的
allocateDirect() 返回的 buffer 对象的内存是在计算机的物理内存中的，可以提高效率
比如：一个 JAVA 程序想要访问系统中的文件，本质上程序发起一个系统调用，操作系统会先将文件数据写到内核地址空间中
然后将内核地址空间将数据拷贝到 JAVA 这个程序的内存中。为了避免这一次的文件数据复制，JVM 直接在物理内存中开辟一个缓存数组，
这个缓存数组直接面对的就是磁盘，其速度当然很快，但还是先写到这个缓存中，然后才写到文件中
因为这个内存写到了物理内存中了，那 JVM 肯定是管不到了，安全性、可控性都比较差

3.2 Channel 通道
负责源节点和目标节点的连接，负责将缓冲区的数据传输
Channel 也是一个抽象父类，有以下几个子类：
FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel
通道的获取是通过静态的方法 getChannel()
本地 IO：
FileInputStream/FileOutputStream
RandomAccessFile

网络 IO：
Socket
ServerSocket
DatagramSocket
这些类都可以获取 Channel 实例，与 Stream 的获取相似
JDK 1.7 以后 NIO 2 中的 open() 和 Files.newByteChannel() 方法也可以获取

4，通道之间的数据传输
transferFrom() 和 transferTo() 可以直接将两个通道进行数据交互，都不需要 Buffer 的参与，也是直接缓冲区

5，分散于聚集
分散读取：将通道中的数据，分散到多个缓冲区中（依次按顺序分散读取到缓冲区，先写第一个，后写第二个等）
聚集写入：将多个缓冲区中的数据，都聚集到通道中（同上）

6，字符集
CharSet类

7，什么是阻塞什么是非阻塞
阻塞和非阻塞是针对网络通信而言的，如果发送端的线程不知道接收端的数据是否可读，那么这个线程就会一直等待着，这就是阻塞
在等待的过程中，这个线程是不会做任何事情的，就浪费了性能。这就是传统 IO 在网络编程上的缺陷
NIO 的非阻塞模式，NIO 使用 Selector 作为选择器，把每一个 Channel 都注册到该选择器上，这个选择器的作用就是来监控这些通道的 IO 状况
包括读、写、建立连接等消息事件
Selector 只会将 Channel 上的请求准备完毕了以后，才会将这个请求转发给服务端的线程上
哦，就是 Selector 起到了一个拦截的作用，他负责保证这些请求是完整的，那服务器只负责处理合理的请求就行了

8，NIO 的优势到底是什么
思考一下，如果我现在的能力，编写一个服务器程序应该怎么编写？
那么就是，服务器主线程一直在 while 中轮序。一旦有请求到来，就使用线程池获取一条线程来处理这个请求
这个线程处理好这个请求之后，再返回到线程池中。那么这就涉及到一些问题：
这是典型的，一个线程对应一个请求，如果有大量的请求来访问服务程序，势必会造成服务器程序线程增多，内存和 CPU 刚不住
且如果线程占满了服务器的线程池，那么后面来的线程就是阻塞住，这就是阻塞 I/O 的由来
所以，就需要一个线程来处理多个请求，这就是 NIO 的能力

NIO 使用一个线程在 while 中轮序监听 Selector 中的 Channel 的时间，如果发生了一些我们监听的时间，那么就可以正常处理
却只是使用了一个线程，而且还可以扩展这个线程，多个线程同时监听 Selector，这也就更好的完成了请求的处理
这也就是非阻塞 I/O 的由来
这是第一个优势

第二个，就是，传统的 I/O 不管是输出还是输出，其数据载体就是内存，将内存写入到磁盘中，需要经过
JAVA 程序内存 -> 内核地址空间（操作系统可控） -> 磁盘
这样的流程涉及到一次用户地址空间和内核地址空间的切换，这样是浪费性能的
而 NIO 中的 Buffer 可以直接申请物理内存，也就是 JVM 之外的内存，相当于直接将数据写到这块内存中
然后直接写入到磁盘，就减少了这一次地址的切换，但是使用它需要注意内存的保障
此外，还可以使用直接内存映射等对象来访问磁盘
