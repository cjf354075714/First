package com.cqu.learn.queueandstack;

/**
 * @author Feng
 * @date 2019/10/23
 *
 *题目：现给定一个数，能够组成它的和的完全平方数量的最小值
 * 例如：
 * 12 = 4 + 4 + 4 => 3
 * 19 = 9 + 9 + 1 => 3
 *
 * 思路：典型的动态规划问题，为什么不能是贪心算法呢
 * 贪心算法的思路是，每次都选取最大的完全平方数去，然后用给定的数去减
 * 比如 12 减去所能容纳的最大的完全平方数 9 等于3，3 只能由 3 个 1 组成
 * 所以贪心算法出来的 12 = 9 + 1 + 1 + 1 => 5 不符合要求
 * 所以只能使用动态规划
 * 动态规划分两种：自顶向下和自底向上
 * 这里使用自顶向上，自顶向上需要先把第一个数据指定，然后利用动态规划公式计算出所有的情况
 * 难的就是这个公式
 *
 * 对于一个数而言，他可能有多种完全平方数的加法组合，需要找出所有的情况，来进行比较
 * 比如，17 = 1+ 4^2 = 2^2 + 2^2 + 3^2
 * 我需要计算出这三种到底哪一种的个数最小，就只能遍历了
 * 如何计算呢，计算的前提是，17 减去一个完全平方数之后，剩余的数要知道他的最小组合数
 * 比如 17 - 16 = 1，明显知道，17 - 9 = 8 ，这里我就需要知道 8 的最小组合数
 * 如何计算 8 的最小组合数呢，这就是一个表面上不是递归，实际上是一个递归的题
 * 有需要去计算 8 的最小组合数，8 = 2^2 + 2^2  = 1 + 1 + ... +1
 * 所以又是一个递归，难点在于，需要去记住每一个数组的最小组合数是多少
 * 在每次计算之前都去直接和初始值进行比较，是不是每次利用都需要一次计算呢?
 * 不是，这是从底层就计算好了的
 */
public class CompleteSquare {

    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for (int i = 0; i < dp.length; i++) {
            dp[i] = i;
        }
        for (int i = 0; i < dp.length; i++) {
            for (int j = 1; i >= j * j; j++) {
                dp[i] = Math.min(dp[i], dp[i - j*j] + 1);
            }
        }
        return dp[n];
    }
}
